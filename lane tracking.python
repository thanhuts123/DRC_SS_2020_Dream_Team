import cv2
import numpy as np
import serial
import pyfirmata as pf
import math as mat
import time

##board =  pf.Arduino('COM3')
##it = pf.util.Iterator(board)
##it.start()
##servo = board.get_pin('d:8:s')

#arduinoData = serial.Serial('com3',9600)
def make_coordinates(image,line_parameters):
    slope, intercept = line_parameters
    y1 = image.shape[0]
    y2 = int(y1*(3/5))
    x1 = int((y1-intercept)/slope)
    x2 = int((y2-intercept)/slope)

    return np.array([x1,y1,x2,y2])
def average_slope_intercept(image,lines):
    left_fit = []
    right_fit = []
    for line in lines:
        x1,y1,x2,y2 = line.reshape(4)
        parameters = np.polyfit((x1,x2),(y1,y2),1)
        slope = parameters[0]
        intercept= parameters [1]
        if slope <0:
          left_fit.append((slope,intercept))
        else:
          right_fit.append((slope,intercept))
    left_fit_average = np.average(left_fit,axis = 0)
    right_fit_average = np.average(right_fit,axis = 0)
    left_line = make_coordinates(image,left_fit_average)
    right_line = make_coordinates(image,right_fit_average)
    print(left_fit_average,'left')
    print(right_fit_average,'right')
    print(left_line)
    print(right_line)
    return np.array([left_line,right_line])

def display_lines(image, lines):
    line_image = np.zeros_like(image)
    if lines is not None:
        for line in lines:
            [x1, y1, x2,y2] = line.reshape(4)
            cv2.line(line_image,(x1,y1),(x2,y2),(0,0,255),15)

    return line_image
def region_of_interest(image):
    height = image.shape[0]
    polygons = np.array([[(17,700),(406,700),(200,350)]])
    mask = np.zeros_like(image)
    cv2.fillPoly(mask,polygons, 255)
    masked_image = cv2.bitwise_and(image,mask)
    return masked_image

cap = cv2.VideoCapture("droid3.mp4")
while (cap.isOpened()):
    _, frame = cap.read()
    hsv_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    blur = cv2.GaussianBlur(hsv_frame,(21,21),0)
    low_blue = np.array([101 ,52, 50])
    high_blue = np.array([130, 255, 255])
    blue_mask = cv2.inRange(blur,low_blue,high_blue)
    blue = cv2.bitwise_and(frame,frame, mask = blue_mask )
    low_yellow = np.array([26,52,50])
    high_yellow = np.array([32,255,255])
    yellow_mask = cv2.inRange(blur,low_yellow,high_yellow)
    yellow = cv2.bitwise_and(frame,frame,mask = yellow_mask)



    canny_blue = cv2.Canny(blue,50,150)
    canny_yellow = cv2.Canny(yellow,50,150)
    #cropped_image = region_of_interest(canny)
    lines_blue = cv2.HoughLinesP(canny_blue,2, np.pi/180,100,np.array([]),minLineLength=25,maxLineGap=5)
    lines_yellow = cv2.HoughLinesP(canny_yellow,2, np.pi/180,100,np.array([]),minLineLength=25,maxLineGap=5)
    #averaged_lines = average_slope_intercept(frame,lines)

         #average = np.average(parameters,axis = 0)
         #average_line = make_coordinates(frame,average)


    #arduinoData.write(0)
    #lines_image = display_lines(frame,averaged_lines)
    #average_image = display_lines(frame,average)
    lines_blue_image = display_lines(frame,lines_blue)
    lines_yellow_image = display_lines(frame,lines_yellow)
    lines_image = cv2.add(lines_blue_image,lines_yellow_image,1,mask=None)
    #combo_image =cv2.addWeighted(frame,0.8,lines_image, 1,1)
    # = cv2.addWeighted(frame,0.8,average_image,1,1)
    combo_blue_image = cv2.addWeighted(frame,0.8,lines_blue_image,1,1)
    combo_yellow_image =cv2.addWeighted(frame,0.8,lines_yellow_image,1,1)
    combo_image = cv2.addWeighted(frame,0.8,lines_image,1,1)
    #cv2.imshow('result',combo_image)
    #cv2.imshow("result_average",combo_image_average)
    #cv2.imshow('result_blue',combo_blue_image)
    #cv2.imshow('result_yellow',combo_yellow_image)
    cv2.imshow('result',combo_image)
    cv2.imshow('blue',blue)
    cv2.imshow('yello',yellow)
    #cv2.imshow('canny',canny)

    key = cv2.waitKey(1) & 0xFF
    if key == ord("q"):
          break
cap.release()
cv2.destroyAllWindows()
